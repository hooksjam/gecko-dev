https://bugzilla.mozilla.org/show_bug.cgi?id=1585806

## Commits

### Reporter patches
Bug 1552608 - Define bitwise operators for SideBits. r=tnikkel

Bug 1552608 - Use SideBits rather than int32_t to represent fixed-position sides in the Layers API. r=tnikkel

### My patch
Bug 1585806 - Make SideBits an enum class, add casting where necessary. r=botond

## Issue

There is an enum called eSideBits that is used in a variety of bitwise operations. It has values such as eSideBitsNone, eSideBitsLeft, eSideBitsTop etc. The issue with this enum is this it is a _plain_ enum when it is safer to user the new c++11 class enum. Plain enums are not type safe and implicitly convert to an integer, whereas c++11 class enums required either casting or operator overrides to perform actions on.

This is beneficial because it forces the programmer to be explicit in their use of the class enum. The main problem with plain enums is that because they implicitly convert to integers they can be used in any ways an integer can. This may result in uses that are not intended or potentially invalid, for example using two enums meant exclusively for bitwise operations with arithmetic operators such as enum\*enum. Incorrect usage like this is difficult to test for because it is perfectly valid to multiply two integers together so no errors will be produced. However, there is likely no situation where multiplying two enums should be used like this, so having a mechanism that will produce errors on incorrect use can prevent programmer mistakes from going unnoticed. 

By changing this to an enum class we can ensure only the desired operators (bitwise in this case) are permitted to be used on the SideBits enums and prevent difficult to track developer errors in the future. 

## Solution:

The solution to this problem is to change enum SideBits to enum class SideBits, and correct the usage (e.g. eSideBitsNone becomes SideBits:eNone). My mentor on this issue has produced a couple of patches to do some preliminary work (listed at the top). Most importantly in these ptaches is the call to 
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS(SideBits), which performs the work to override bitwise operators. This step is important because it is one of the key distinctions between plain enums and c++11 class enums. By explicitly defining which operators we want to override we limit the operations on the enum to our intended use cases.

Once the type is changed from enum to enum class there will be numerous usages of the enum that will become invalid. The next step will be to identify the errors and correct the usage, likely with a static_cast<int>(). This is the second main point of the change, if a programmer wants to use an enum outside of its intended use they may still do so, but they must be explicit that they are casting the value to an integer. This situation mostly occurs when comparing the enum to an enum of a different type, for which no operator overrides will be defined. This extra step ensures the programmers are deliberate with their intention, reducing the chance of incorrect usage.

## Test Plan:

This fix doesn't require explicit testing, but it can be demonstrated that the new format will be less prone to error. 

### Scenario 1

Consider this scenario that could arise from the use of a plain enum.

```c++
SideBits testBits = eSideBitsLeftRight
if(testBits * eSideBitsLeft) {
	return true;
} else {
	return false;
}
```

Perhaps the programmer intended to use the condition testBits & eSideBitsLeft, but accidentally put a * character instead of an &. With the plain enum this situation would produce no errors, and the programmer might not understand why their work isn't functioning properly until they waste time debugging and tracking down their mistake.

Now consider the same scenario with our improved enum class.

```c++
SideBits testBits = SideBits::eLeftRight
if(testBits * SideBits::eLeft) {
	return true;
} else {
	return false
}
```

Since we have not defined a * operator override for the SideBits class enum this would produce the error 

> invalid operands to binary expression ('mozilla:SideBits' and 'mozilla:SideBits')

letting the developer know they have incorrectly used these values. 

### Scenario 2

Consider this scenario that will arise immediately after changing all eSideBits to SideBits::

```c++
int testBits = 1;
if(testBits & eSideBitsLeft) {
	return true;
} else {
	return false;
}
```

Before the change this was perfectly valid because it was simply performing a bitwise operation between two integers. We assume this was the programmers intended behaviour. Now consider the same scenario with our improved enum class.

```c++
int testBits = 1;
if(testBits & SideBits::eLeft) {
	return true;
} else {
	return false;
}
```

Because the built in MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS() only creates operator overrides between SideBits enums, this will produce the error

> invalid operands to binary expression (‘int’ and 'mozilla:SideBits')

 because there is no compatible operation between these two, even though it is still the programmers indented behaviour. The programmer sees the error and must change the code finally to.

```c++
int testBits = 1;
if(testBits & static_cast<int>(SideBits::eLeft)) {
	return true;
} else {
	return false;
}
```

While this is a small bit of extra work on the programmers part, it reinforces that this is their indented behaviour, and reduces the chance of them performing an invalid operation with the SideBits enum.

### Built in testing

Upon changing the enum to a class enum, the testing plan will consist of running ./mach build, and identifying any errors that occur. They will likely all be a result of Scenario 2 and which will require the casting fix. After fixing all occurrences I will run ./mach test to ensure the change did not break any other functionality.

## Conclusions

By improving the type safety of the SideBits enum with this c++11 feature we ensure the programmer is explicit with their use of the SideBits enum and prevent time lost on difficult to track errors caused by misuse.
